@page "/"
@using Microsoft.AspNetCore.SignalR.Client
@using System.Runtime.InteropServices
@using Qynit.PulseGen.Server.Hubs
@using Qynit.PulseGen.Server.Models;
@using Qynit.PulseGen.Server.Services
@using System.IO.Pipelines;
@using System.Buffers;
@using System.Collections.Concurrent;
@using System.Threading.Channels;
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject IPlotService PlotService
@implements IAsyncDisposable
@implements IPlotClient

<div class="box">
    <div @ref="_chart" class="row content" />
</div>

@code
{
    private HubConnection? _hubConnection;
    private ElementReference _chart;
    private IJSObjectReference? _module;
    private DotNetObjectReference<Index>? _objRef;
    private Task? _renderTask;
    private CancellationTokenSource? _renderCts;
    private ConcurrentDictionary<string, bool> _channelNewValue = new();
    private ConcurrentDictionary<string, bool> _channelVisible = new();
    private Channel<string> _renderQueue = Channel.CreateUnbounded<string>();

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri(PlotHub.Uri))
            .Build();

        _hubConnection.On<IEnumerable<string>>(nameof(ReceiveNames), ReceiveNames);

        await _hubConnection.StartAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _module = await JS.InvokeAsync<IJSObjectReference>("import", "./Pages/Index.razor.js");
            _objRef = DotNetObjectReference.Create(this);
            await _module.InvokeVoidAsync("init", _chart, _objRef);
            _renderCts = new();
            _renderTask = RenderInBackground(_renderCts.Token);
        }
    }

    [JSInvokable]
    public async ValueTask VisibilityChanged(string name, bool visible)
    {
        var flag = false;
        _channelVisible.AddOrUpdate(name, visible, (k, v) =>
        {
            flag = visible && !v;
            return visible;
        });
        if (flag)
        {
            await EnqueueRender(name);
        }
    }

    public async Task ReceiveNames(IEnumerable<string> names)
    {
        foreach (var name in names)
        {
            _channelNewValue[name] = true;
            await EnqueueRender(name);
        }
    }

    private async ValueTask EnqueueRender(string name)
    {
        await _renderQueue.Writer.WriteAsync(name);
    }

    private async Task RenderInBackground(CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            var name = await _renderQueue.Reader.ReadAsync(token);
            if (ChannelNeedUpdate(name) && ChannelShouldRender(name))
            {
                await RenderWaveform(name, token);
                _channelNewValue[name] = false;
            }
        }
    }

    private bool ChannelNeedUpdate(string name)
    {
        return _channelNewValue.TryGetValue(name, out var needUpdate) && needUpdate;
    }

    private bool ChannelShouldRender(string name)
    {
        var hasValue = _channelVisible.TryGetValue(name, out var visible);
        return !hasValue || visible;
    }

    private async ValueTask RenderWaveform(string name, CancellationToken token)
    {
        if (PlotService.TryGetPlot(name, out var arc))
        {
            using (arc)
            {
                var pipe = new Pipe();
                var writer = pipe.Writer;
                writer.Write(MemoryMarshal.AsBytes(arc.Target.DataI));
                writer.Write(MemoryMarshal.AsBytes(arc.Target.DataQ));
                await writer.CompleteAsync();
                using var streamRef = new DotNetStreamReference(pipe.Reader.AsStream());
                var dataType = DataType.Float32;
                var isReal = arc.Target.IsReal;
                await _module!.InvokeVoidAsync("renderWaveform", token, name, dataType, isReal, streamRef);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        _renderCts?.Cancel();
        if (_renderTask is not null)
        {
            try
            {
                await _renderTask;
            }
            catch (OperationCanceledException) { }
        }
        _renderCts?.Dispose();
        _objRef?.Dispose();
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
        if (_module is not null)
        {
            try
            {
                await _module.DisposeAsync();
            }
            catch (JSDisconnectedException) { }
        }
    }
}