@page "/"
@using Microsoft.AspNetCore.SignalR.Client
@using System.Runtime.InteropServices
@using Qynit.PulseGen.Server.Hubs
@using Qynit.PulseGen.Server.Models;
@using Qynit.PulseGen.Server.Services
@using Qynit.PulseGen.Server.Shared
@using System.IO.Pipelines;
@using System.Buffers;
@using System.Collections.Concurrent;
@using System.Threading.Channels;
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject IPlotService PlotService
@implements IAsyncDisposable
@implements IPlotClient

<div class="box">
    <div class="aside">
        <FluentDataGrid RowsData="@FilteredTraces">
            <PropertyColumn Property="@(p => p.Name)" Sortable="true">
                <ColumnOptions>
                    <FluentSearch @bind-Value="_nameFilter" />
                </ColumnOptions>
            </PropertyColumn>
            <TemplateColumn>
                <HeaderCellItemTemplate>
                    <TriCheckbox @bind-Value="AnyVisible" Indeterminate="IsIndeterminate">Show</TriCheckbox>
                </HeaderCellItemTemplate>
                <ChildContent>
                    <FluentCheckbox @bind-Value="@context.Visible" />
                </ChildContent>
            </TemplateColumn>
        </FluentDataGrid>
    </div>
    <div class="plot">
        <WaveformViewer Names="VisibleTraceNames" PlotService="PlotService"/>
    </div>
</div>

@code
{
    private HubConnection? _hubConnection;
    private string _nameFilter = string.Empty;

    private class Trace
    {
        public string Name { get; set; } = string.Empty;
        public bool Visible { get; set; }
        public bool NeedUpdate { get; set; }
    }

    private List<Trace> Traces { get; set; } = new();
    private IEnumerable<string>? VisibleTraceNames => Traces.Where(p => p.Visible).Select(p => p.Name).ToList();
    IQueryable<Trace> FilteredTraces => Traces.AsQueryable().Where(p => p.Name.Contains(_nameFilter));
    private bool AnyVisible
    {
        get => FilteredTraces.Any(p => p.Visible);
        set
        {
            foreach (var p in FilteredTraces)
            {
                p.Visible = value;
            }
        }
    }
    private bool IsIndeterminate => FilteredTraces.Any(p => p.Visible) && FilteredTraces.Any(p => !p.Visible);

    protected override void OnInitialized()
    {
        var names = PlotService.GetNames();
        Traces = names.Select(x => new Trace { Name = x, Visible = true, NeedUpdate = true }).ToList();
    }

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri(PlotHub.Uri))
            .Build();

        _hubConnection.On<IEnumerable<string>>(nameof(ReceiveNames), ReceiveNames);

        await _hubConnection.StartAsync();
    }

    public async Task ReceiveNames(IEnumerable<string> names)
    {
        var tracesLookUp = Traces.ToDictionary(x => x.Name);
        foreach (var name in names)
        {
            if (tracesLookUp.TryGetValue(name, out var trace))
            {
                trace.NeedUpdate = true;
            }
            else
            {
                Traces.Add(new Trace { Name = name, Visible = true, NeedUpdate = true });
            }
        }
        await InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }
}