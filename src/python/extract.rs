use ndarray::ArrayView;
use numpy::{prelude::*, Ix1, Ix2, PyArray, PyArray1, PyArray2};
use pyo3::{exceptions::PyTypeError, intern, prelude::*, sync::GILOnceCell, types::PyDict};

pub(crate) type IqMatrix = Wrapper<IqMatrixInner>;
pub(crate) type OffsetArray = Wrapper<OffsetInner>;
pub(crate) type IirArray = Wrapper<IirInner>;
pub(crate) type FirArray = Wrapper<FirInner>;

#[derive(Debug)]
pub(crate) struct Wrapper<T>(T);

impl<T> Wrapper<T>
where
    T: PyArrayWrapper,
{
    pub(crate) fn clone_ref(&self, py: Python<'_>) -> Self {
        Self(self.0.clone_ref(py))
    }

    pub(crate) fn as_array<'a, 'py: 'a>(&'a self, py: Python<'py>) -> ArrayView<'a, T::T, T::D> {
        self.0.as_array(py)
    }
}

#[derive(Debug)]
pub(crate) struct IqMatrixInner(Py<PyArray2<f64>>);

impl PyArrayWrapper for IqMatrixInner {
    type T = f64;
    type D = Ix2;
    const ERR_MSG: &'static str = "IQ matrix should be convertible to a 2x2 f64 numpy array.";

    fn inner(&self) -> &Py<PyArray<Self::T, Self::D>> {
        &self.0
    }

    fn wrap(arr: Py<PyArray<Self::T, Self::D>>) -> Self {
        Self(arr)
    }

    fn check(arr: &Bound<'_, PyArray<Self::T, Self::D>>) -> bool {
        arr.dims() == [2, 2]
    }
}

#[derive(Debug)]
pub(crate) struct OffsetInner(Py<PyArray1<f64>>);

impl PyArrayWrapper for OffsetInner {
    type T = f64;
    type D = Ix1;
    const ERR_MSG: &'static str = "offset should be convertible to a 1d f64 numpy array.";

    fn inner(&self) -> &Py<PyArray<Self::T, Self::D>> {
        &self.0
    }

    fn wrap(arr: Py<PyArray<Self::T, Self::D>>) -> Self {
        Self(arr)
    }

    fn check(_arr: &Bound<'_, PyArray<Self::T, Self::D>>) -> bool {
        true
    }
}

#[derive(Debug)]
pub(crate) struct IirInner(Py<PyArray2<f64>>);

impl PyArrayWrapper for IirInner {
    type T = f64;
    type D = Ix2;
    const ERR_MSG: &'static str = "iir should be convertible to a Nx6 f64 numpy array. Usually this is generated by scipy.signal routines.";

    fn inner(&self) -> &Py<PyArray<Self::T, Self::D>> {
        &self.0
    }

    fn wrap(arr: Py<PyArray<Self::T, Self::D>>) -> Self {
        Self(arr)
    }

    fn check(arr: &Bound<'_, PyArray<Self::T, Self::D>>) -> bool {
        arr.dims()[1] == 6
    }
}

#[derive(Debug)]
pub(crate) struct FirInner(Py<PyArray1<f64>>);

impl PyArrayWrapper for FirInner {
    type T = f64;
    type D = Ix1;
    const ERR_MSG: &'static str = "fir should be convertible to a 1d f64 numpy array.";

    fn inner(&self) -> &Py<PyArray<Self::T, Self::D>> {
        &self.0
    }

    fn wrap(arr: Py<PyArray<Self::T, Self::D>>) -> Self {
        Self(arr)
    }

    fn check(_arr: &Bound<'_, PyArray<Self::T, Self::D>>) -> bool {
        true
    }
}

pub(crate) trait PyArrayWrapper: Sized {
    type T: numpy::Element;
    type D: ndarray::Dimension;
    const ERR_MSG: &'static str;
    fn inner(&self) -> &Py<PyArray<Self::T, Self::D>>;
    fn wrap(arr: Py<PyArray<Self::T, Self::D>>) -> Self;
    fn check(arr: &Bound<'_, PyArray<Self::T, Self::D>>) -> bool;

    fn extract(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
        let err_msg = Self::ERR_MSG;
        let arr = np_as_readonly_array(ob).map_err(|e| PyTypeError::new_err((err_msg, e)))?;
        let arr = arr
            .downcast_into::<PyArray<Self::T, Self::D>>()
            .map_err(|_| PyTypeError::new_err(err_msg))?;
        if !Self::check(&arr) {
            return Err(PyTypeError::new_err(err_msg));
        }

        Ok(Self::wrap(arr.unbind()))
    }

    fn clone_ref(&self, py: Python<'_>) -> Self {
        Self::wrap(self.inner().clone_ref(py))
    }

    fn as_array<'a, 'py: 'a>(&'a self, py: Python<'py>) -> ArrayView<'a, Self::T, Self::D> {
        let arr = self.inner().bind(py);
        // SAFETY: self.0 is private and no methods provide mutable access to it.
        unsafe { arr.as_array() }
    }
}

impl<'py, T> FromPyObject<'py> for Wrapper<T>
where
    T: PyArrayWrapper,
{
    fn extract_bound(ob: &Bound<'py, PyAny>) -> PyResult<Self> {
        Ok(Self(T::extract(ob)?))
    }
}

impl<T> ToPyObject for Wrapper<T>
where
    T: PyArrayWrapper,
{
    fn to_object(&self, py: Python<'_>) -> PyObject {
        self.0.inner().to_object(py)
    }
}

fn np_as_readonly_array<'py>(ob: &Bound<'py, PyAny>) -> PyResult<Bound<'py, PyAny>> {
    static AS_ARRAY: GILOnceCell<PyObject> = GILOnceCell::new();
    let py = ob.py();
    let as_array = AS_ARRAY
        .get_or_try_init(py, || -> PyResult<PyObject> {
            Ok(py.import_bound("numpy")?.getattr("asarray")?.into())
        })?
        .bind(py);
    let arr = as_array.call1((ob, <f64 as numpy::Element>::get_dtype_bound(py)))?;
    let kwargs = PyDict::new_bound(py);
    kwargs.set_item(intern!(py, "write"), false)?;
    arr.getattr(intern!(py, "setflags"))?
        .call((), Some(&kwargs))?;
    Ok(arr)
}
