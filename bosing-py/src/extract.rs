use std::convert::Infallible;

use ndarray::{ArrayView, prelude::*};
use numpy::{Ix1, Ix2, PyArray, prelude::*};
use pyo3::{Borrowed, exceptions::PyTypeError, prelude::*, sync::PyOnceLock};

macro_rules! define_wrapper {
    ($name:ident, $t:ty, $d:ty, $err_msg:expr $(, $check:expr)*) => {
        #[derive(Debug, Clone)]
        pub struct $name(ArcArray<$t, $d>);

        impl $name {
            pub(crate) fn view(&self) -> ArrayView<'_, $t, $d> {
                self.0.view()
            }
        }

        impl<'a, 'py> FromPyObject<'a, 'py> for $name {
            type Error = PyErr;

            fn extract(obj: Borrowed<'a, 'py, PyAny>) -> Result<Self, Self::Error> {
                let err_msg = $err_msg;
                let arr =
                    np_as_array_from_borrowed(obj).map_err(|e| PyTypeError::new_err((err_msg, e)))?;
                let arr = arr
                    .cast_into::<PyArray<$t, $d>>()
                    .map_err(|_| PyTypeError::new_err(err_msg))?;
                $(
                if !$check(&arr) {
                    return Err(PyTypeError::new_err(err_msg));
                }
                )*

                Ok(Self(arr.to_owned_array().into()))
            }
        }

        impl<'py> IntoPyObject<'py> for $name {
            type Target = PyArray<$t, $d>;
            type Output = Bound<'py, Self::Target>;
            type Error = Infallible;

            fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {
                Ok(PyArray::from_array(py, &self.0))
            }
        }

        impl<'a, 'py> IntoPyObject<'py> for &'a $name {
            type Target = PyArray<$t, $d>;
            type Output = Bound<'py, Self::Target>;
            type Error = Infallible;

            fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {
                Ok(PyArray::from_array(py, &self.0))
            }
        }
    };
}

define_wrapper!(
    IqMatrix,
    f64,
    Ix2,
    "IQ matrix should be convertible to a 2x2 f64 numpy array.",
    |arr: &Bound<'_, PyArray<f64, Ix2>>| arr.dims() == [2, 2]
);

define_wrapper!(
    OffsetArray,
    f64,
    Ix1,
    "offset should be convertible to a 1d f64 numpy array."
);

define_wrapper!(
    IirArray,
    f64,
    Ix2,
    "iir should be convertible to a Nx6 f64 numpy array. Usually this is generated by scipy.signal routines.",
    |arr: &Bound<'_, PyArray<f64, Ix2>>| arr.dims()[1] == 6
);

define_wrapper!(
    FirArray,
    f64,
    Ix1,
    "fir should be convertible to a 1d f64 numpy array."
);

fn np_as_array_from_borrowed<'py>(ob: Borrowed<'_, 'py, PyAny>) -> PyResult<Bound<'py, PyAny>> {
    static AS_ARRAY: PyOnceLock<Py<PyAny>> = PyOnceLock::new();
    let py = ob.py();
    let as_array = AS_ARRAY
        .get_or_try_init(py, || -> PyResult<Py<PyAny>> {
            Ok(py.import("numpy")?.getattr("asarray")?.into())
        })?
        .bind(py);
    as_array.call1((ob, <f64 as numpy::Element>::get_dtype(py)))
}
